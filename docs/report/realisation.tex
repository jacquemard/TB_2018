\chapter{Réalisation}\label{realisation}

\section{Capture d'images}\label{realisation.capture}
\subsection{Emplacement de la caméra}
En date du 29 mai 2018, la caméra a été installée, connectée au réseau et est fonctionnelle. La photo présentée en figure \ref{fig:cam_parking_annotation} est une vue aérienne du site de Cheseaux de la HEIG-VD. C'est ici qu'un parking sera filmé.

\begin{figure}[H]
    \includegraphics[width=14cm]{img/conception/cam_parking_location.png}
    \centering
    \captionsource{Emplacement de la caméra (en rouge) et du parking filmé (en vert)}{map:heig-vd}
    \label{fig:cam_parking_annotation}
\end{figure} 

Y est désigné par un cercle rouge l'emplacement de la caméra. Elle se situe sur la terrasse du bâtiment est, accessible au niveau K. Elle est orientée afin de pouvoir capturer des images du parking désigné en vert. 

Malheureusement, lors des tests effectués après réception de la caméra \textbf{Wanscam} \textit{HW0029-5}, il a été remarqué que le signal Wifi présent sur le toit n'était pas suffisamment fiable afin de connecter la caméra. Afin de palier à ce problème, un câble réseau Ethernet a tout de même pu être tiré de manière temporaire.

\subsection{Configuration des périphériques}
Dans cette sous-section, on trouvera des informations utiles concernant la caméra et la machine virtuelle. Ces informations seront utilisées dans la suite de ce rapport. 

Afin de pouvoir accéder à la caméra, un FQDN\footnote{\textit{FQDN}: \textit{Fully qualified domain name}, soit nom de domaine entièrement qualifié. \autocite{wiki:FQDN}} a été configuré. Celui-ci permet d'obtenir l'adresse IP de la caméra à l'aide du DNS local. Ainsi, plutôt que de s'adresser à elle par une adresse IP, il suffit d'utiliser en lieu et place l'adresse suivante:
\begin{center}
    \textit{ipcam.einet.ad.eivd.ch}
\end{center}

%\nomenclature{FQDN}{\textit{Fully qualified domain name}, soit nom de domaine entièrement qualifié}

Comme indiqué en section \ref{conception.architecture.capture.logique}, une VM est mise à disposition de ce projet afin de récupérer des images de la caméra. Son adresse IP, 10.192.75.100, est fixe.

\subsection{Requêtes et protocole}
La caméra \textbf{Wanscam} \textit{HW0029-5} expose un serveur web permettant sa configuration. Bien entendu, celui-ci permet des connexions authentifiées. Il utilise le protocole \textit{Basic Auth HTTP\footnote{Le protocole Basic Auth consiste à inclure dans les entêtes HTTP un champ \textit{Authorization}. Celui-ci contient le login et le mot de passe de l'utilisateur, sous forme encodée (\textit{Base64})}}\autocite{wiki:basic-auth}. Il est cependant important de remarquer que le serveur ne permet pas l'utilisation d'\textit{HTTPS}: ainsi, la connexion n'est pas chiffrée. Le mot de passe fournit à la caméra, bien qu'encodé, circule en clair sur le réseau. Il est  donc important de noter que dans le cadre d'une application professionnelle, ceci n'est pas envisageable.

Elle expose un \textit{endpoint} \textit{HTTP} permettant de récupérer l'image actuelle que filme la caméra. Ainsi, dans le cadre de ce projet, l'adresse \textit{http://ipcam.einet.ad.eivd.ch/web/tmpfs/snap.jpg} est utilisée. La figure \ref{fig:image_request} présente donc ce protocole de communication qui est utilisé afin de récupérer des images.

\begin{figure}[H]
    \includegraphics[width=130mm]{img/realisation/cam_request.png}
    \centering
    \caption{Requête d'une image à la caméra \textbf{Wanscam} \textit{HW0029-5}}
    \label{fig:image_request}
\end{figure} 

\subsection{Agent}
Un agent a été développé, déployé sur la VM. Celui-ci permet de définir un intervalle auquel des images seront demandées à la caméra. Il permet donc de gérer la connexion à celle-ci, mais aussi les pertes de liaisons. A la réception d'une image, il permet de définir une méthode de traitement (décrite en section \ref{conception.traitement} et \ref{realisation.traitement}). 
Il permet aussi de définir, si tel est souhaité, une heure de début et une heure de fin durant lesquelles les requêtes seront effectuées. Lorsqu'on sort de cet intervalle, aucune photo ne sera capturée. Dans notre cas, celui-ci est utilisé afin d'éviter une multitude d'images prises du parking vide aux heures de nuit.

On trouvera au listing \ref{lst:agent} la création en python de celui-ci. Il faut remarquer qu'il n'a pas été souhaité de préciser les constantes \lstinline[columns=fixed]{USERNAME} et \lstinline[columns=fixed]{PASSWORD} pour des raisons de confidentialité. Il est aussi nécessaire de préciser que \lstinline[columns=fixed]{handle_image} est la fonction qui décrit le traitement effectué sur chaque image reçue. Celle-ci sera décrite en section \ref{realisation.traitement}

% spellcheck-language "en"
\begin{lstlisting}[caption={Création d'un agent récupérant les images}, label={lst:agent}] 
CAMERA_HOST = "ipcam.einet.ad.eivd.ch"
IMAGE_REQUEST_MIN_DELTA = 60
IMAGE_REQUEST_START_TIME = time(4, 30) # Start time at  4h30 AM
IMAGE_REQUEST_STOP_TIME = time(23) # Stop time at 11 PM
# [...]

# Creating a camera client
camera = CameraClient(CAMERA_HOST, USERNAME, PASSWORD)
# Creating a agent which requests the camera for an image once every hour
agent = CameraAgent(camera, handle_image, minutes = IMAGE_REQUEST_MIN_DELTA, running_time=(IMAGE_REQUEST_START_TIME, IMAGE_REQUEST_STOP_TIME))
\end{lstlisting}
% spellcheck-language

Ainsi, une image sera demandée toutes les heures, de 4h30 à 11h.

\subsection{Monitoring}
La caméra utilisée fonctionne sur batterie et panneaux solaires. Ainsi, il a semblé important de pouvoir surveiller le bon fonctionnement du système, et d'être averti en cas de malfonctionnement afin de pouvoir agir au plus vite. On pensera notamment à une perte de connexion due à des batteries faibles (par exemple, suite à un manque de soleil sur plusieurs jours consécutifs), ou encore à un câble déconnecté.

\textit{Python} offre un système complet natif de journalisation. Lorsque ce système est utilisé dans les modules créés, il est aisé de traiter des logs, et même d'avertir par mail des erreurs produites. Ce module peut être importé grâce à l'instruction \lstinline[columns=fixed]{import logging}.

Ce système offre plusieurs niveau de log. On les trouvera ci-dessous, du plus critique au moins important\autocite{doc:log}:
\begin{itemize}
    \item \lstinline[columns=fixed]{CRITICAL}
    \item \lstinline[columns=fixed]{ERROR}
    \item \lstinline[columns=fixed]{WARNING}
    \item \lstinline[columns=fixed]{INFO}
    \item \lstinline[columns=fixed]{DEBUG}
    \item \lstinline[columns=fixed]{NOTSET}
\end{itemize}

Ainsi, le niveau de chacun des logs effectués lors de la capture d'image a été défini. Une liste des logs importants concernant ce monitoring est proposée ci-dessous:
\begin{description}
    \item[INFO] Une image a été capturée et bien reçue
    \item[ERROR] La connexion à la caméra a été perdue
    \item[INFO] La caméra n'est toujours pas accessible
    \item[WARNING] La connexion à la caméra a été rétablie
\end{description}

\textit{Python} permet d'écouter les logs émis par un module. Il est aussi possible de définir le niveau d'écoute. Par exemple, il peut être souhaité de capturer tous les logs de niveau \textit{WARNING}. Dans ce cas, tous les logs de ce type seront capturés, ainsi que tous les logs dont le niveau est supérieur (soit plus important). 

Lors de l'arrivée d'un log, un système de \textit{handler} (proposé par \textit{Python}) a été mis en place. On en distinguera 3:
\begin{description}
    \item[Terminal handler] Ecoute les logs à partir du niveau \textit{INFO}. A l'arrivée d'un log, celui-ci est affiché dans la console. Les informations de debug ne sont pas affichées.
    \item[File handler] Ecoute tous les logs. Ainsi, une trace est gardée de tous les logs dans le système de fichier. Ce gestionnaire est de type \lstinline[columns=fixed]{TimedRotatingFileHandler}, qui permet de créer un nouveau fichier de logs par jour. 
    \item[SMTPHandler] Ecoute les logs à partir du niveau \textit{WARNING}. Lors d'une erreur ou d'un avertissement, un mail est envoyé automatiquement.
\end{description}

Ainsi, il est possible d'agir rapidement lors d'une perte de connexion à la caméra. Le log associé étant de type (\textit{ERROR}), un mail est envoyé à l'aide du \textit{SMTPHandler}. Si la caméra est reconnectée (\textit{WARNING}), un mail est aussi reçu.

\section{Traitement des images}\label{realisation.traitement}

La figure \ref{fig:image_process} présente la récupération et le traitement des images qui est effectué.

\begin{figure}[ht]
    \includegraphics[width=110mm]{img/realisation/image_process.png}
    \centering
    \caption{Requêtes d'images et traitement}
    \label{fig:image_process}
\end{figure} 

Dans un premier temps, un script Python interroge la caméra et récupère une image tel qu'il a été décrit en section \ref{realisation.capture} précédente. Ensuite, l'image est sous-échantillonnée, et les bords détectés. Pour ce faire, \textit{Scikit-image} a été utilisé.

Le code \ref{lst:handling_image} présenté montre la méthode traitant les images entrantes. Celles-ci sont passées en argument de la méthode (\lstinline[columns=fixed]{image_stream}).


% spellcheck-language "en"
\begin{lstlisting}[caption={Traitement des images reçues}, label={lst:handling_image}] 
# Defining what to do when an image is received
def handle_image(image_stream):
    # Converting to a skimage/opencv image (simply a [x, y, 3] numpy array)
    image = io.imread(image_stream)

    # Firstly, downsampling the image
    image = transform.resize(image, IMAGE_OUTPUT_SIZE, mode='reflect', anti_aliasing=True)

    # Secondly, detecting the edges
    image = scharr_hsv(image)

    # Then, we output the image to the folder
    # We use a hash as an ID
    # We could have used a datetime format as a unique filename, but this could results to a lack of privacy
    # Saving it as a bitmap: no decompression to do when loading a lot of file
    # Note: hashing time is negligible
    h = hash(image.data.tobytes())
    filename = IMAGE_FOLDER + hex(h)[-15:] + ".bmp"

    with warnings.catch_warnings(): # used to ignore loss of precision warning
        warnings.simplefilter("ignore")
        io.imsave(filename, image)

    # We then have to reset metadata access and edit time because of privacy issues
    os.utime(filename, (946684800, 946684800))
\end{lstlisting}
% spellcheck-language

La méthode \lstinline[columns=fixed]{_scharr_hsv} utilisée est décrite au listing de code \ref{lst:scharr_filter}. 

Il est possible d'y distinguer la ligne \lstinline[columns=fixed]{@adapt_rgb(hsv_value)}, 

provenant de la librairie \textit{scikit-image}. Elle permet d'adapter le filtre \textit{scharr} présent dans la méthode sur chacun des canaux de l'image.

% spellcheck-language en
\begin{lstlisting}[caption={Détection de bord à l'aide de \textit{scikit-image}}, label={lst:scharr_filter}] 
@adapt_rgb(hsv_value)
def _scharr_hsv(image):
    return filters.scharr(image)
\end{lstlisting}
% spellcheck-language

Dans le cadre de l'anonymisation des données, il a semblé important qu'aucune information concernant les utilisateurs de puisse apparaître. C'est pourquoi le nom de l'image est basée sur son hash (fonction de hash fournie par Python. Un hash complexe n'est pas nécessaire). 

L'image est ensuite sauvegardée à un format \textit{bitmap} (\textit{.bmp}), sans pertes de compression. La date et heure de création et de modification du fichier est aussi modifiée pour que les données soient au plus anonymisées.

\section{Création d'un corpus d'images annoté}

Pas d'annotations faites à la main sur le parking

On fait tout sur pklot, plus de liberté de tests puisque pas d'image pré-annotée.

\todo{Traitement dataset, aussi effacer les voitures non détectée par pklot}

\section{Création du modèle}

\section{Entrainement du modèle}


\todo{Moyenne sur plusieurs images à la suite du parking: utilisation du modèle}




